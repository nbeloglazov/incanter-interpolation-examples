\section{Язык программирования Clojure}

Clojure \cite{clojure} - современный диалект языка программирования Lisp. Clojure - язык программирования общего назначения с поддержкой разработки в интерактивном режиме, поощряющий функциональное программирование, и упрощающий поддержку многопоточности. Clojure работает на платформе JVM (Java Virtual Machine), что предоставляет доступ ко множеству библиотек написанных для данной платформы.

\subsection{Основные возможности языка}

Clojure является функциональным языком программирования с поддержкой функций в качестве объектов первого класса (first class objects) и неизменяемыми (за исключением специальных случаев) данными, включая поддержку "ленивых" коллекций данных. От Lisp'а Clojure "унаследовал" макросы, мультиметоды и интерактивный стиль разработки, а JVM дает переносимость и доступ к большому набору библиотек, созданных для этой платформы.

Неизменность структур данных позволяет использовать их в разных потоках выполнения программы, что упрощает многопоточное программирование. Однако не все структуры являются неизменяемыми — в нужных случаях программист может явно использовать изменяемые структуры данных, используя Software Transactional Memory (STM), что обеспечивает надежную работу в многопоточной среде.

За счет того, что Clojure был спроектирован для работы на базе JVM, обеспечивается доступ к большому набору библиотек, существующих для данной платформы. Взаимодействие с Java реализуется в обе стороны — как вызов кода, написанного на Java, так и реализация классов, которые доступны как для вызова из Java, так и из других языков, существующих для JVM, например, Scala.

В clojure присутствуют макросы. Макросы — это мощное средство уменьшения сложности кода, позволяющие строить проблемно-ориентированную среду на основе базового языка. Макросы активно используются в Clojure, и множество конструкций, составляющих язык, определены как макросы на основе ограниченного количества специальных форм и функций, реализованных в ядре языка. Макросы в Clojure смоделированы по образцу макросов в Common Lisp, и являются функциями, которые выполняются во время компиляции кода. В результате выполнения этих функций должен получиться код, который будет подставлен на место вызова макроса.

\subsection{Примеры}

Определение нормы трёхмерного вектора

\begin{minted}[gobble=2,frame=single]{clojure}
  (defn norm [[x y z]]
  (Math/sqrt (+ (* x x) (* y y) (* z z))))

  (norm [1 2 3]) ; 3.7416573867739413
  (norm [1 0 1]) ; 1.4142135623730951
\end{minted}

Приближённое вычисление производной в точке по формуле: \( f' \approx \frac{f(x+h) - f(x)}{h}\)

\begin{minted}[gobble=2,frame=single]{clojure}
(defn derivative [f x]
 (let [h 0.00001]
   (/ (- (f (+ x h))
         (f x))
      h)))

(defn f1 [x] x)       ; f1(x) = x
(defn f2 [x] (* x x)) ; f2(x) = x * x

(derivative f1 0) ; f1'(0) = 1
(derivative f2 0) ; f2'(0) = 0.00001
(derivative f2 4) ; f2'(4) = 8.00001
\end{minted}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../document"
%%% End:
